// Code generated by cmd/cgo; DO NOT EDIT.

//line mkcp.go:1:1
package mkcp; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -I ${SRCDIR}
#cgo lkcp LDFLAGS: -lkcp
#cgo kcpa LDFLAGS: -lkcp -lm -ldl
#cgo linux,!lkcp,!kcpa LDFLAGS: -L${SRCDIR} -lkcp
#cgo darwin,!lkcp,!kcpa LDFLAGS: -lkcp
#cgo freebsd,!kcpa LDFLAGS: -lkcp
#cgo windows,!lkcp LDFLAGS: -L${SRCDIR} -lkcp -lmingwex -lmingw32

#include <kcp/ikcp.h>
#include <stdlib.h>

#include "mgokcp.h"
*/
import _ "unsafe"
import (
	"sync"
	"unsafe"
)

//KCPGoOutputFunc kcp go output function
type KCPGoOutputFunc func([]byte, interface{}) int32

var (
	_kcpMallocSync    *sync.Mutex
	_kcpMallocRecorde map[uintptr][]byte
)

//New 创建一个KCP
func New(conv uint32, user interface{}) *KCP {
	goKcp := &KCP{_usr: user}

	goKcp._kcp = ( /*line :35:15*/_Cfunc_mkcp_create /*line :35:27*/)( /*line :35:29*/_Ctype_uint /*line :35:35*/(conv),  /*line :35:43*/_Ctype_uintptr_t /*line :35:54*/(uintptr(unsafe.Pointer(goKcp))))
	return goKcp
}

//Free 释放一个KCP
func Free(kcp *KCP) {
	func() { _cgo0 := /*line :41:17*/kcp._kcp; _cgoCheckPointer(_cgo0); _Cfunc_mkcp_release(_cgo0); }()
}

//export go_output
func go_output(buf []byte, ptr uintptr) int {
	kcp := (*KCP)(unsafe.Pointer(ptr))
	return  /*line :47:9*/_Ctype_int /*line :47:14*/(kcp._output(buf, kcp._usr))
}

//export go_malloc
func go_malloc(sz uint) uintptr {
	_kcpMallocSync.Lock()
	defer _kcpMallocSync.Unlock()

	/*gsliceBuf := make([]byte, sz)
	if gsliceBuf == nil {
		return 0
	}

	addr := uintptr(C.mkcp_go_addr(C.GoSlice(gsliceBuf)))
	_kcpMallocRecorde[addr] = gsliceBuf*/

	return 0
}

//export go_free
func go_free(ptr uintptr) {
	if ptr == 0 {
		return
	}

	_kcpMallocSync.Lock()
	defer _kcpMallocSync.Unlock()
	if _, ok := _kcpMallocRecorde[ptr]; ok {
		delete(_kcpMallocRecorde, ptr)
	}
}

//UseGoAllocator 使用Golang 管理内存
func UseGoAllocator() {
	_kcpMallocRecorde = make(map[uintptr][]byte)
	_kcpMallocSync = &sync.Mutex{}
}

//KCP Connection
type KCP struct {
	_kcp    * /*line :87:11*/_Ctype_struct_IKCPCB /*line :87:19*/
	_usr    interface{}
	_output KCPGoOutputFunc
}

//WithOutput 设置输出回调函数
func (slf *KCP) WithOutput(output KCPGoOutputFunc) {
	slf._output = output
}

//User 返回KCPConn的表示参数
func (slf *KCP) User() interface{} {
	return slf._usr
}

//Recv 接收数据
func (slf *KCP) Recv(buffer []byte) int32 {
	//return int32(C.mkcp_recv(slf._kcp, C.GoSlice(buffer)))
	return 0
}

//Send 发送数据
func (slf *KCP) Send(buffer []byte) int32 {
	//return int32(C.mkcp_send(slf._kcp, C.GoSlice(buffer)))
	return 0
}

//Update ....
func (slf *KCP) Update(current uint32) {
	func() { _cgo0 := /*line :116:16*/slf._kcp; var _cgo1 _Ctype_IUINT32 = _Ctype_uint(current); _cgoCheckPointer(_cgo0); _Cfunc_ikcp_update(_cgo0, _cgo1); }()
}

//Check ...
func (slf *KCP) Check(current uint32) uint32 {
	return int32(func() _Ctype_IUINT32{ _cgo0 := /*line :121:28*/slf._kcp; var _cgo1 _Ctype_IUINT32 = _Ctype_uint(current); _cgoCheckPointer(_cgo0); return _Cfunc_ikcp_check(_cgo0, _cgo1); }())
}

//Input 对接收到的数据进行处理
func (slf *KCP) Input(data []byte) int32 {
	//return int32(C.mkcp_input(slf._kcp, C.GoSlice(data)))
	return 0
}

//Flush 输出数据直接回调到KCP的output函数
func (slf *KCP) Flush() {
	func() { _cgo0 := /*line :132:15*/slf._kcp; _cgoCheckPointer(_cgo0); _Cfunc_ikcp_flush(_cgo0); }()
}

//PeekSize ...
func (slf *KCP) PeekSize() int32 {
	return int32(func() _Ctype_int{ _cgo0 := /*line :137:31*/slf._kcp; _cgoCheckPointer(_cgo0); return _Cfunc_ikcp_peeksize(_cgo0); }())
}

//SetMTU default 1400
func (slf *KCP) SetMTU(mtu int32) int {
	return int32(func() _Ctype_int{ _cgo0 := /*line :142:29*/slf._kcp; var _cgo1 _Ctype_int = /*line :142:39*/mtu; _cgoCheckPointer(_cgo0); return _Cfunc_ikcp_setmtu(_cgo0, _cgo1); }())
}

//WndSize 色织窗口
func (slf *KCP) WndSize(sndWnd, rcvWnd int32) int32 {
	return func() _Ctype_int{ _cgo0 := /*line :147:24*/slf._kcp; var _cgo1 _Ctype_int = _Ctype_int(sndWnd); var _cgo2 _Ctype_int = /*line :147:49*/rcvWnd; _cgoCheckPointer(_cgo0); return _Cfunc_ikcp_wndsize(_cgo0, _cgo1, _cgo2); }()
}

//WaitSnd ...
func (slf *KCP) WaitSnd() int32 {
	return func() _Ctype_int{ _cgo0 := /*line :152:24*/slf._kcp; _cgoCheckPointer(_cgo0); return _Cfunc_ikcp_waitsnd(_cgo0); }()
}

//NoDelay 设置延迟
func (slf *KCP) NoDelay(nodelay, interval, resend, nc int32) int32 {
	return ( /*line :157:9*/_Cfunc_ikcp_nodelay /*line :157:22*/)( /*line :157:24*/_Ctype_int /*line :157:29*/(nodelay),
		 /*line :158:3*/_Ctype_int /*line :158:8*/(interval),
		 /*line :159:3*/_Ctype_int /*line :159:8*/(resend),
		 /*line :160:3*/_Ctype_int /*line :160:8*/(nc))
}

//GetConv ....
func (slf *KCP) GetConv(ptr []byte) uint32 {
	v := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :165:16*/ptr; _cgoCheckPointer(_cgo0); return _Cfunc_CBytes(_cgo0); }()
	n := ( /*line :166:7*/_Cfunc_ikcp_getconv /*line :166:20*/)(slf._kcp, v)
	func() { _cgo0 := /*line :167:9*/v; _cgoCheckPointer(_cgo0); _Cfunc_free(_cgo0); }()

	return uint32(n)
}

// setup allocator
//void ikcp_allocator(void* (*new_malloc)(size_t), void (*new_free)(void*))
//IUINT32 ikcp_getconv(const void *ptr)
